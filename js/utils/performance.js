/**
 * Performance Optimization Module for Leo Oli Photography Portfolio
 * Improves loading times and overall site performance
 */

const PerformanceOptimizer = (function() {
    // Configuration
    const config = {
      imagesToPreload: 4,  // Number of images to preload beyond viewport
      debounceTime: 150,   // Debounce time for resize events
      intersectionThreshold: 0.1, // Threshold for intersection observer
      criticalAssets: [    // Critical assets to preload
        'assets/img/logo.png', 
        'assets/img/favicon.png'
      ]
    };
    
    // State tracking
    let state = {
      initialized: false,
      resourceHints: [],
      deferredScripts: [],
      metrics: {
        initialLoadTime: 0,
        firstImageLoadTime: 0
      }
    };
    
    /**
     * Initialize performance optimizations
     */
    function initialize() {
      if (state.initialized) return;
      
      // Mark start time for metrics
      const startTime = performance.now();
      
      // Add resource hints
      addResourceHints();
      
      // Optimize critical rendering path
      optimizeCriticalPath();
      
      // Initialize image optimizations
      optimizeImages();
      
      // Set up performance monitoring
      monitorPerformance();
      
      // Defer non-critical scripts
      deferNonCriticalScripts();
      
      // Record initialization metrics
      state.metrics.initialLoadTime = performance.now() - startTime;
      state.initialized = true;
      
      return state.metrics;
    }
    
    /**
     * Add resource hints for faster loading
     */
    function addResourceHints() {
      // DNS prefetch for external resources
      addDnsPrefetch('https://cdnjs.cloudflare.com');
      addDnsPrefetch('https://fonts.googleapis.com');
      addDnsPrefetch('https://fonts.gstatic.com');
      addDnsPrefetch('https://maxcdn.bootstrapcdn.com');
      addDnsPrefetch('https://i.ibb.co');
      
      // Preconnect to critical domains
      addPreconnect('https://cdnjs.cloudflare.com');
      addPreconnect('https://fonts.googleapis.com');
      
      // Preload critical assets
      config.criticalAssets.forEach(asset => {
        addPreload(asset, 'image');
      });
    }
    
    /**
     * Add DNS prefetch hint
     * @param {string} url - Domain to prefetch
     */
    function addDnsPrefetch(url) {
      const link = document.createElement('link');
      link.rel = 'dns-prefetch';
      link.href = url;
      document.head.appendChild(link);
      state.resourceHints.push(link);
    }
    
    /**
     * Add preconnect hint
     * @param {string} url - Domain to preconnect to
     */
    function addPreconnect(url) {
      const link = document.createElement('link');
      link.rel = 'preconnect';
      link.href = url;
      link.crossOrigin = 'anonymous';
      document.head.appendChild(link);
      state.resourceHints.push(link);
    }
    
    /**
     * Add preload hint
     * @param {string} url - Resource URL to preload
     * @param {string} as - Resource type (e.g., 'image', 'style', 'script')
     */
    function addPreload(url, as) {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.href = url;
      link.as = as;
      document.head.appendChild(link);
      state.resourceHints.push(link);
    }
    
    /**
     * Optimize critical rendering path
     */
    function optimizeCriticalPath() {
      // Inline critical CSS for above-the-fold content if needed
      const criticalCSS = getCriticalCSS();
      if (criticalCSS) {
        const style = document.createElement('style');
        style.textContent = criticalCSS;
        document.head.appendChild(style);
      }
      
      // Defer loading of non-critical CSS
      deferCSSLoading();
    }
    
    /**
     * Get critical CSS for above-the-fold content
     * @returns {string|null} Critical CSS or null
     */
    function getCriticalCSS() {
      // This would typically be generated by a build tool
      // Here we return a minimal set of critical styles
      return `
        :root {
          --primary-gold: #e3ca66;
          --secondary-gold: #b48e47;
          --dark-bg: #212121;
          --text-light: #d4d4d4;
        }
        body {
          background: var(--dark-bg);
          margin: 0;
          padding: 0;
          font-family: 'Open Sans', sans-serif;
          color: var(--text-light);
        }
        .header {
          padding: 1.5rem 0;
          text-align: center;
        }
        #logo {
          max-width: 400px;
          width: 80%;
          height: auto;
          margin: 0 auto;
          display: block;
        }
        .loading-indicator {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 50px;
          height: 50px;
          border: 3px solid rgba(227, 202, 102, 0.3);
          border-radius: 50%;
          border-top-color: var(--primary-gold);
          animation: spin 1s ease-in-out infinite;
          z-index: 9999;
        }
        @keyframes spin {
          to {
            transform: translate(-50%, -50%) rotate(360deg);
          }
        }
      `;
    }
    
    /**
     * Defer loading of non-critical CSS
     */
    function deferCSSLoading() {
      // Find non-critical stylesheets
      const stylesheets = document.querySelectorAll('link[rel="stylesheet"]:not([data-critical="true"])');
      
      stylesheets.forEach(stylesheet => {
        // Save original attributes
        const href = stylesheet.href;
        
        // Convert to preload
        stylesheet.rel = 'preload';
        stylesheet.as = 'style';
        stylesheet.onload = function() {
          // Once preloaded, apply as stylesheet
          this.rel = 'stylesheet';
          this.onload = null;
        };
      });
    }
    
    /**
     * Optimize image loading
     */
    function optimizeImages() {
      // Early return if IntersectionObserver is not supported
      if (!('IntersectionObserver' in window)) return;
      
      // Find all grid items with images
      const gridItems = document.querySelectorAll('.grid-item img');
      
      // Set up image optimization
      optimizeImageLoading(gridItems);
    }
    
    /**
     * Optimize image loading with smart preloading
     * @param {NodeList} images - Collection of images to optimize
     */
    function optimizeImageLoading(images) {
      // Skip if no images
      if (!images.length) return;
      
      // Track loaded images
      const loadedImages = new Set();
      
      // Create intersection observer for images
      const imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            const src = img.getAttribute('data-src') || img.src;
            
            if (src && !loadedImages.has(src)) {
              // Load the image
              loadImage(img, src);
              loadedImages.add(src);
              
              // Unobserve after loading
              imageObserver.unobserve(img);
              
              // Preload nearby images
              preloadNearbyImages(img, images);
            }
          }
        });
      }, {
        rootMargin: '200px 0px',
        threshold: config.intersectionThreshold
      });
      
      // Observe all images
      images.forEach(img => {
        // Skip already processed images
        if (img.classList.contains('loaded')) return;
        
        // Prepare lazy loading
        prepareImageForLazyLoading(img);
        
        // Start observing
        imageObserver.observe(img);
      });
    }
    
    /**
     * Prepare image for lazy loading
     * @param {HTMLImageElement} img - Image element
     */
    function prepareImageForLazyLoading(img) {
      // Store original source
      const originalSrc = img.src;
      if (originalSrc && !img.hasAttribute('data-src')) {
        img.setAttribute('data-src', originalSrc);
      }
      
      // Set a lightweight placeholder
      if (!img.classList.contains('lazy')) {
        img.classList.add('lazy');
        
        // Set transparent placeholder
        img.src = 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1"%3E%3C/svg%3E';
      }
    }
    
    /**
     * Load image
     * @param {HTMLImageElement} img - Image element
     * @param {string} src - Image source URL
     */
    function loadImage(img, src) {
      // Use Image constructor for better control
      const tempImage = new Image();
      
      // Track when the first image loads
      if (!state.metrics.firstImageLoadTime) {
        tempImage.onload = function() {
          img.src = src;
          img.classList.add('loaded');
          
          // Record metrics
          state.metrics.firstImageLoadTime = performance.now();
        };
      } else {
        tempImage.onload = function() {
          img.src = src;
          img.classList.add('loaded');
        };
      }
      
      tempImage.onerror = function() {
        console.error('Failed to load image:', src);
        img.classList.add('error');
      };
      
      // Start loading
      tempImage.src = src;
    }
    
    /**
     * Preload nearby images for smoother experience
     * @param {HTMLImageElement} currentImg - Current image
     * @param {NodeList} allImages - All images
     */
    function preloadNearbyImages(currentImg, allImages) {
      // Find current image index
      const imageArray = Array.from(allImages);
      const currentIndex = imageArray.indexOf(currentImg);
      
      if (currentIndex === -1) return;
      
      // Preload next few images
      for (let i = 1; i <= config.imagesToPreload; i++) {
        const nextIndex = (currentIndex + i) % imageArray.length;
        const nextImg = imageArray[nextIndex];
        
        if (!nextImg.classList.contains('loaded')) {
          const nextSrc = nextImg.getAttribute('data-src');
          if (nextSrc) {
            const preloadImg = new Image();
            preloadImg.src = nextSrc;
          }
        }
      }
    }
    
    /**
     * Defer loading of non-critical scripts
     */
    function deferNonCriticalScripts() {
      // Find scripts to defer
      const scripts = document.querySelectorAll('script:not([data-critical="true"])');
      
      scripts.forEach(script => {
        // Skip inline scripts without src
        if (!script.src) return;
        
        // Create a deferred version
        const deferredScript = document.createElement('script');
        deferredScript.src = script.src;
        deferredScript.defer = true;
        
        // Copy other attributes
        Array.from(script.attributes).forEach(attr => {
          if (attr.name !== 'src' && attr.name !== 'type') {
            deferredScript.setAttribute(attr.name, attr.value);
          }
        });
        
        // Replace original script
        script.parentNode.replaceChild(deferredScript, script);
        state.deferredScripts.push(deferredScript);
      });
    }
    
    /**
     * Set up performance monitoring
     */
    function monitorPerformance() {
      // Set up Performance Observer if available
      if ('PerformanceObserver' in window) {
        // Track largest contentful paint
        const lcpObserver = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          const lastEntry = entries[entries.length - 1];
          
          // Store LCP metric
          state.metrics.largestContentfulPaint = lastEntry.startTime;
          
          console.log('Largest Contentful Paint:', lastEntry.startTime);
        });
        
        lcpObserver.observe({ type: 'largest-contentful-paint', buffered: true });
        
        // Track first input delay
        const fidObserver = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          const firstEntry = entries[0];
          
          // Store FID metric
          state.metrics.firstInputDelay = firstEntry.processingStart - firstEntry.startTime;
          
          console.log('First Input Delay:', state.metrics.firstInputDelay);
        });
        
        fidObserver.observe({ type: 'first-input', buffered: true });
      }
      
      // Track and report page load time
      window.addEventListener('load', () => {
        // Calculate and store page load time
        state.metrics.pageLoadTime = performance.now();
        
        console.log('Page fully loaded:', state.metrics.pageLoadTime);
      });
    }
    
    /**
     * Get all performance metrics
     * @returns {Object} Current performance metrics
     */
    function getMetrics() {
      return { ...state.metrics };
    }
    
    // Public API
    return {
      initialize,
      getMetrics
    };
  })();
  
  // Usage example
  // document.addEventListener('DOMContentLoaded', () => {
  //   PerformanceOptimizer.initialize();
  // });